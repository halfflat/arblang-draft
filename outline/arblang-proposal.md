# Arblang proposal (WIP)

Arblang is a language for defining the dynamics and effects of Arbor 'mechanisms'. A mechanism is a stateful process whose evolution over time is governed by a system of ODEs and by responses to external events, and which in turn acts upon the cellular state to which the mechanism is applied.

The arblang language is constrained so that every evolution and effect can be interpreted _symbolically_ as closed form expressions. This is to permit the automatic analysis of these expressions for the purposes of determining a priori analytic solutions or appropriate ODE approximation techniques, and to automatically determine, for example, time derivatives of effect values through symbolic or automatic differentiation. Consequently common programming constructs such as unbounded iteration or recursion are precluded.

Arblang nonetheless can also be interpreted in a purely numerical fashion in other contexts.


# Mechanism semantics

A mechanism can be one of a number of different _classes_ of mechanism, where each class determines the sort of cell interactions that the mechanism performs. The classes are pre-defined, but are open ended, in that further extensions to Arbor may admit new mechanism classes. The basic set of classes are described as follows:

* _Density mechanisms_ describe processes with spatial extent, and their effects are described in terms of current densities and molar fluxes of ionic and nonionic species. They do not receive events.

* _Concentration models_ determine the evolution of internal or external spieces concentration over some spatial extent, based upon the species fluxes and other cellular state. They also do not receive events.

* _Point mechanisms_ describe localized processes, with effects defined in terms of currents and molar flow rates. They can change their state in response to spikes from other cells from connections that are bound to them, or to spikes generated by the cell on which they are placed.

Each of these mechanisms can have a _state_ comprising zero or more named values that vary over time. Each mechanism definition will provide the initial values for this state, and define their evolution by an explicit system of ODEs.


## External bindings

The definition of a mechanism allows for names to be bound to the mechanism state and various cellular quantities so that they can play a role in defining the evolution and effects of the mechanism.

The list of possible cellular quantities is open to future extension, but initially are as follows:

* _State_ refers to the evolving state of the mechanism itself.

* _Membrane potential_ is the potential difference across the cellular membrane.

* _Temperature_ is the local temperature at the cellular membrane.

* _Molar flux_ is the local transmembrane flux associated with an ionic or nonionic species.

* _Current density_ is the local transmembrane current associated with an ionic species. This is related to the species molar flux by the ionic charge and the Faraday constant.

* _Charge_ is the fixed electrical charge of an ionic species, given as a dimensionless multiple of the the elementary charge.

* _Internal concentration_ and _external concentration_ are the intracellular and extracellular concentrations respectively of a species, in the vicintiy of the cellular membrane.

Not every mechanism class has access to every cellular quantity. In particular, only concentration models have access to current densities and molar fluxes.


## Effects

Effects define how the mechanism state influences the cellular state. The list of possible effects is open to future extension, but the initial effects are as follows:

* _Current_ defines an ionic current contribution or non-specific current contribution (one not explicitly associated with any ionic species) to the transmembrane currents by a localized process.

* _Current density_ defines similarly a contribution to the ionic or non-specific transmembrane current densities by a process with spatial extent.

* _Molar flow rate_ defines a contribution to the transmembrane flow of a species by a localized process.

* _Molar flux_ defines a contribution the transmembrane flux of a species by a process with spatial extent.

* _Internal concentration rate_ and _External concentration rate_ define the contribution to the rate of change in the intracellular or extracellular concentrations respectively of a given species.

A mechanism can define an effect in terms of an ionic current (or current density) or in terms of a species flow (or flux), but not both. A current defines an ionic flow, and vice versa.

Restrictions:

* Concentration models can only have concentratione effects.

* Point mechanisms can only have current or molar flow rate effects.

* Density mechanisms can only have current density or molar flux effects.


## Events

As noted above, point mechanisms can receive _events_, upon which their state can be modified according to some formula. There are currently two supported sorts of events:

* _Event_ is triggered when by a spike on an attached connection. It has a scalar value equal to the connect weight.

* _Post_ is triggered when a spike is generated on the post-synaptic cell. There may be a delay between the spike generation and the _post_ event; the value of the _post_ event is the time between the spike generation and the event delivery.


## Parameters

A mechanism can include _parameters_. These are named quantities with a default value that are constant throughout the evolution of a mechanism's state, but which can be overriden with user-supplied values when the mechanism is used in a cell model.

For a parameter to be settable, it must be explicitly exported in the mechanism definition.


# Lexical grammar

Tokenization is governed by a grammar, described below in a variant of BNF, with the notation:

* Names for non-terminals are written in _italics_ and may not contain spaces.

* Non-terminals that constitue tokens are written in ***bold-italics***.

* Terminals are written in `monospace`, denoting the exact character sequence thus represented.

* A terminal may also be written as a unicode code point, as 'U+' followed by four or five hexadecimal digits followed optionally by the literal character and then optionally by the unicode name in all capitals.

* A set of single character terminals can be denoted by {expr} where _expr_ is a one- or two-letter Unicode general category abbreviation, indicating the corresponding collection of characters, or a binary Unicode property, indicating the collection of characters for which the property has the value 'Yes'.

* A set of single character terminals can also be denoted by a character class […] following the syntax described in [Unicode Regular Expressions](https://www.unicode.org/reports/tr18) sections 0.1.1, 1.2.4, and 1.3.

* Symbols can be grouped with parentheses.

* Alternatives are delimitted by a vertical bar |.

* An asterisk indicates the preceding symbol or group is repeated zero or more times.

* A plus sign indicates the preceding symbol or group is repeated one or more times.

* A question mark indicates the preceding symbol or group may be omitted, that is, it can appear at most one time.


## Character set

Arblang source is represented as a sequence of Unicode characters in normalization form C (NFC), excluding unassigned characters, surrogate code points, noncharacters, and byte order marks. It is the responsibility of the interpreting environment to transform any particular source encoding to this representation.


## Tokenization

A lexically valid Arblang source must admit a tokenization as a sequence of ***comment*** tokens, ***whitespace*** tokens, ***symbol*** tokens, ***string-literal*** tokens, ***superscript-literal*** tokens, ***numeric-literal*** tokens, and punctuation tokens.

A token has an associated value, which may be empty. If not empty, it is the result of applying a token-specific canonicalization process.
With the exception of string literals, canonicalization first applies Unicode compatibility normalization NFKC to the token text, then further processing as detailed below.


### Comments

A comment is introduced by `#` and then extends to the end of the line. It is the only context in which a line end is not regarded simply as whitespace.

> ***comment*** ::= U+0023 `#` NUMBER SIGN _comment-character_* _new-line_
>
> _comment_character_ ::= [^\\u{000A}\\u{000B}\\u{000C}\\u{000D}\\u{0085}\\u{2028}\\u{2029}]
>
> _new-line_ ::= _cr_ | _lf_ | _cr_ _lf_ | _other-newline_
>
> _lf_ ::= U+000A LINE FEED
>
> _cr_ ::= U+000D CARRIAGE RETURN
>
> _other-new-line_ ::= U+0085 NEXT LINE | U+2028 LINE SEPARATOR | U+2029 PARAGRAPH SEPARATOR

#### Token value

A ***comment*** token has no value.

#### Notes

A _comment-character_ is any character that is not the first character of _new-line_. New line characters and sequences correspond to the [line boundaries requirement RL1.6 of Unicode Regular Expressions](https://www.unicode.org/reports/tr18/#RL1.6).


### Whitespace

In some expressions, where it denotes multiplication, whitepace is mandatory, but otherwise whitespace is not significant. It comprises any non-empty sequence of characters with the White_Space property.

> ***whitespace*** ::= {White_Space}\+

#### Token value

A ***whitespace*** token has no value.


### Symbols

Symbols correspond to Arblang identifiers and keywords. Arblang keywords are generally contextual: the interpretation of a symbol as an identifier or a keyword is determined in parsing.

> ***symbol*** ::= _symbol-start_ _symbol-continue_\* | _symbol-degree-prefixed_
>
> _symbol-start_ ::= {L} | {Nl} | {Other_ID_Start}
>
> _symbol-continue_ ::= _symbol-start_ | {Nd} | {Mn} | {Mc} | {Pc} | _prime-mark_
>
> _prime-mark_ ::= U+0027 `'` APOSTROPHE | U+02B9 `ʹ` MODIFIER LETTER PRIME | U+2032 `′` PRIME
>
> _symbol-degree-prefixed_ ::= U+00B0 `°` DEGREE SIGN {L}+ | U+2109 `℉` DEGREE FARENHEIT | U+2109 `℃` DEGREE CENTIGRADE

#### Token value

Canonicalization substitutes any character in _prime-mark_ with U+0027 APOSTROPHE after performing NFKC normalization.

#### Notes

Identifiers broadly follow the conventions of Python, except:
* `_` is not a valid _symbol-start_.
* A ***symbol*** may contain _prime-mark_ characters.
* Special degree-sign prefixed symbols are permitted, in order to represent temperature scales. Compatability characters U+2109 `℉` and U+2109 `℃` will be converted to `°F` and `°C` respectively in NFKC normalization.
* Characters that are only _compatibility_ equivalent to an acceptable _symbol_ character are not permitted. In particular, superscript numerals are not permitted within a _symbol_.


### Superscript literals

A superscript literal is used to denote exponents in the absence of the exponentiation operator.

> ***superscript-literal*** ::= _superscript-minus_? _superscript-digit_+
>
> _superscript-minus_ ::= U+207B `⁻` SUPERSCRIPT MINUS
>
> _superscript-digit_ ::= `⁰` | `¹` | `²` | `³` | `⁴` | `⁵` | `⁶` | `⁷` | `⁸` | `⁹`

#### Token value

After NFKC normalization, which takes superscript digits and minus to regular digits and U+2212 MINUS SIGN, the token value is canonicalized by mapping U+2212 to U+002d `-` HYPHEN-MINUS.


### Numeric literals

Numeric literals represent both fractional and integer literal values.

> ***numeric-literal*** ::= _digit-sequence_ (_decimal-separator_ _digit-sequence_)? _exponent_?
>
> _digit-sequence_ ::= ( `0` | `1` | `2` | `3` | `4` | `5` | `6` | `7` | `8` | `9` )+ ( _digit-group-separator_ _digit_sequence_)?
>
> _digit-group-separator_ ::= U+0027 `'` APOSTROPHE | _whitespace_
>
> _decimal-separator_ ::= U+002E `.` FULL STOP
>
> _exponent_ ::= _whitespace_? _exponent-E_ | _exponent-alternate_
>
> _exponent-E_ ::= ( 'E' | 'e' ) _sign_? _digit-sequence_
>
> _exponent-alternate_ ::= U+00D7 `×` MULTIPLICATION SIGN _whitespace_? `10` _superscript-literal_
>
> _sign_ ::= U+002B `+` PLUS SIGN | U+002D `-` HYPHEN-MINUS | U+2212 `−`MINUS SIGN

#### Token value

After normalization, which takes superscript digits and minus to regular digits and U+2212 MINUS SIGN, the token value is canonicalized as follows.
* Any _digit-group-separator_ is removed (including all whitespace).
* U+2212 MINUS SIGN is mapped to U+002D `-` HYPHEN-MINUS.
* U+002B PLUS SIGN is removed.
* Exponential markers `e` and `×10` are replaced with `E`.

#### Notes

* The use of whitespace as a digit group separator is intended to accommodate SI practice of writing long numbers, e.g. `10 000 000` for 10⁶.
* The alternate scientific number syntax `1.234 45 × 10³` is allowed in order to support standard SI practice. `×` is not used elsewhere as an arithmetic operator.
* The apostrophe digit separator is also used in C++14 for integer literals.
* In order to accommodate loss-free rescaling of unit-bearing quantities, real and integer literals in arithmetic contexts should have an internal representation that maintains a normalized signifcand and a power of ten scale.


### String literals

String literals encode arbitrary character sequences used to specify and identify interface and species names.

> ***string-literal*** ::= `"` ( [^&#92;"]* | _escape-sequence_ )\* `"`
>
> _escape-sequence_ ::= `\\` | `\"`

#### Token value

The value is taken as the characters between the initial and final `"` characters, followed by the replacement of each _escape-sequence_: `\\` by `\` and `\"` by `"`.

#### Notes

The value of a ***string-literal*** token does _not_ undergo NFKC normalization, and so comprises an arbitrary sequence of Unicode characters in NFC normalization. While the syntax allows arbitary white space within a literal, including line separators and similar, the interpreting environment might impose further restrictions on what constitutes a valid interface name, for example.


### Punctuation

> _punctuation_ ::=
>     ***plus-sign*** | ***minus-sign*** | ***multiplication-dot*** | ***division-slash*** | ***exponent-op*** |
>     ***compare-equal*** | ***compare-not-equal*** | ***compare-less*** | ***compare-less-eqaul*** | ***compare-greater*** | ***compare-greater-eqaul*** |
>     ***left-arrow*** | ***right-arrow*** | ***right-left-arrow*** |
>     ***assign-equal*** | ***semicolon*** | ***left-paren*** | ***right-paren*** | ***left-brace*** | ***right-brace*** |
>     ***colon*** | ***bar*** | ***comma*** | ***period***

Punctuation token definitions:

> ***plus-sign*** ::= `+`

> ***minus-sign*** ::= U+002D `-` HYPHEN-MINUS | U+2212 `−`MINUS SIGN

> ***multiplication-dot*** ::= U+00B7 `·` MIDDLE DOT | U+22C5 `⋅` DOT OPERATOR

> ***division-slash*** ::= ~ U+002F `/` SOLIDUS | U+2215 `∕` DIVISION SLASH

> ***exponent-op*** ::= `^`

> ***compare-equal*** ::= `==`

> ***compare-not-equal*** ::= `!=` | U+2260 `≠` NOT EQUAL TO

> ***compare-less*** ::= `<`

> ***compare-less-equal*** ::= `<=` | U+2264 `≤` LESS-THAN OR EQUAL TO

> ***compare-greater*** ::= `>`

> ***compare-greater-eqaul*** ::= `>=` | U+2265 `≥` GREATER-THAN OR EQUAL TO

> ***left-arrow*** ::= `<-` | U+2190 `←` LEFTWARDS ARROW

> ***right-arrow*** ::= `->` | U+2192 `→` RIGHTWARDS ARROW

> ***right-left-arrow*** ::= `<->` | U+21C4 `⇄` RIGHT ARROW OVER LEFT ARROW

> ***assign-equal*** ::= `=`

> ***semicolon*** ::= `;`

> ***left-paren*** ::= `(`

> ***right-paren*** ::= `)`

> ***left-brace*** ::= `{`

> ***right-brace*** ::= `}`

> ***colon*** ::= `:`

> ***bar*** ::= U+007C `|` VERTICAL LINE

> ***comma*** ::= `,`

> ***period*** ::= `.`

#### Token value

Punctuation tokens have no value.


# Arblang syntax and semantics

The syntax definitions below are defined in terms of the tokens defined in the lexical grammar, with the following conventions:

* A ***symbol*** token can represent an identifier or a keyword; keywords in the syntax descriptions are written in `monospace`, and should be interpreted as ***symbol*** tokens with the corresponding value.

* Where ***whitespace*** is present in a syntax rule, it is required, but additional ***whitespace*** tokens are permitted anywhere in the (tokenized) arblang source, where they are ignored.

* For readability in syntax rules, the text representation of a punctuation token, styled monospace, may stand in for the punctuation token itself. So, for example, `=` might stand for the token ***assign-equal***.

An arblang source document comprises a series of module and interface definitions.

> _source_ ::= ( _module-defn_ | _interface-defn_ )+

Module and interface definitions are described below.

## Identifiers and scope

Identifiers are represented by ***symbol*** tokens and depending on context, may refer to:
1. a module,
2. an imported module,
3. a constant,
4. a parameter,
5. a function,
6. an external binding,
7. a type alias,
8. a regime,
9. a record field,
10. a function argument,
11. or a local value binding.

### Scopes

The association of an identifier with its referrent is called a _binding_, and that binding is valid only within a _scope_. With one exception for regime names, an identifer's scope does not precede the point where that identifier is introduced by some declaration or binding.

**Global scope.**
A module definition introduces the module name into the following global scope. The environment may also introduce module names defined in other arblang sources.

**Module scope.**
Within a module or interface definition, top-level parameter, constant, type alias, and function definitions have module scope, as do module imports and external bindings. The scope extends from after the definition or import, until the end of the enclosing module or interface. Identifiers bound in module scope can be made visible in other modules as a _qualified-identifier_ after a module import.

**Function scope.**
Function arguments have function scope, which extends until the end of the function definition.

**Regime scope.**
All top-level regime definitions in an interface have as scope the entire interface definition, even preceding the regime definition. The same applies within a region definition: the scope of an internal region identifier is the entire body of the region definition. An internal region identifier is visible as a _qualified-identifier_ elsewhere within the same interface definition.

**Expression scope.**
`let` and `with` binding expressions introduce new identifiers that have as scope the final expression in the binding.

**Record scope.**
Field names introduced in a record type or record value have record scope, which extends to the end of the record type or record value construction.

Scope form a hierarchy of inner and outer scopes, with the outermost scope being the global scope.

### Context

Two different identifers with the same ***symbol*** may be bound in the same scope, if they are in different _contexts_. There are five distinct contexts in arblang:

1. _Module_ context applies wherever a module name is being introduced in a module definition, or where a module is referenced in a module import clause.
2. _Type context_ applies in type expressions and where a type alias is introduced.
3. _Regime context_ applies in regime clauses and where a regime name is introduced in a regime definition.
4. _Record context_ applies to field names within a record type description or in a record value construction.
5. _Expression context_ applies within value expressions, function argument definitions, the definition of parameters, constants, functions, and in the association of an identifier with an imported module.

Each context can be regarded as constituting a different namespace for identifiers.

### Masking

An identifer bound in a given context in an outer scope may be _masked_ by a binding of an identifier with the same ***symbol*** in an inner scope. This is permitted only in the following circumstances:

1. An identifer bound in expression context in a function scope by a function argument or in expression scope by a `let` or `with` binding may mask an identifer in an outer scope.
2. An identifier bound in regime context in an inner regime definition may mask a regime identifer in an outer regime or interface scope.

It is otherwise an error to bind an identifer with the same ***symbol*** as an already bound identifier in the same context.

### Qualified identifers

A qualified identifer is a term of the form:

> _qualified-identifier_ ::= ***symbol*** ( `.` ***symbol*** )\*

A qualified identifier of the form α._id_, where α is a (qualified) identifier and _id_ is an identifier, is bound to the referent of _id_ in the scope determined by α:

1. In an expression context, if α is bound to a record value, then α._id_ is bound to the value of the field named _id_ in α.
3. In an expression context, if α is bound to an imported module, then α._id_ is bound to the constant, parameter, or function bound to _id_ in the module refered to by α.
2. In a type context, if α is bound to an imported module, then α._id_ is bound to the type bound to _id_ in in the module refered to by α.
3. In a region context, f α is bound to a regime, then α._id_ is bound to the inner regime named _id_ in α.

### Examples

```
# Binds 'foo' in module context, global scope.
module foo {
    # Binds 't' in expression context, module scope.
    def t: time = 10 s;
}

module bar {
    # Binds 'foo' in type context, module scope.
    type foo = length;

    # Binds 'foo' in expression context, module scope.
    def foo: foo = 3 m;

    # Refers to 'foo' in module context, from outer global scope.
    # Binds 'F' in expression context, module scope.
    import foo as F;

    # Binds 'quux' in expression context, module scope.
    def quux =
        # 'let' rebinds 'F' in the subsequent expression context in
        # expression scope.
        #
        # On the right hand side, 'F' is still bound to the module import,
        # and 'u', a record field name, is bound in record context in the
        # scope of the record value construct.
        #
        # 'F.t' is a qualified identifier, that is bound to the constant 't'
        # defined in the module 'foo'.
        let F = { u = F.t; };

        # 'F' refers to the record above; 'F.u' is a qualified identifier
        # that refers to the value bound to the field 'u' in 'F'.
        F.u / 20 s;

    # Error: foo cannot refer to both a value and an imported module in module scope.
    import foo;

    # Error: foo cannot refer to both a value and a function in module scope.
    def foo = fn () → 4;
}
```

## Types and literals

Every expression has a type, which is either:

1. Boolean.
2. A quantity (see below).
3. A record type, comprising an unordered sequence of named fields, with each field being either a quantity or another record type.
4. A function.

A type expression _type-expr_ identifies a particular type, and is used in type assertions and function argument specifiers. Function types have no corresponding type expression: expressions of a function type may only be bound to an identifier or used in a function application expression. In particular, they may not be used as an argument in a function application.

A _type-expr_ is either `boolean`, a quantity term, a record type description, or a (qualified) identifier bound to a type expression by a type alias.

> _type-expr_ ::= `boolean` | _quantity-term_ | _record-type-expr_ | _qualified-identifier_

An expression of a given type can be constructed from type literals and constructors described below, as well as from operators acting on subexpressions (see the section _Expressions_).

### Boolean

The boolean type has two possible values, true and false, and expressions of boolean type are constructed from the boolean literals and comparison expressions.

> _boolean-literal_ ::= `true` | `false`

The boolean literals are keywords in an expression context, and may not be used as identifiers in this context.

### Quantities

Quantities represent physical quantities, which in turn comprise a magnitude and a physical dimension. The specific unit scale underlying the representation of a physical quantity is implicit.

A quantity type is defined as a product term of named quantities such as voltage, time, resistance, etc. The set of named quantities is predefined, and cannot be extended within arblang.

> _quantity-term_ ::= _quantity-name_ _integer-exponent_? | _quantity-product_ | _quantity-quotient_
>
> _quantity-product_ ::= _quantity-term_ ( ***whitespace*** | ***multiplication-dot*** )  _quantity-term_
>
> _quantity-quotient_ ::= _quantity-term_ ***division-slash*** _quantity-term_
>
> _integer-exponent_ ::= `^` ***numeric-literal*** |  ***superscript-literal***
>
> _quantity-name_ ::= `real` | `length` | `mass` | `time` | `current` | `temperature` | `amount` |
>   `frequency` | `area` | `volume` | `velocity` | `acceleration` | `momentum` | `force` | `pressure` | `power` | `energy` |
>   `entropy` | `charge` | `voltage` | `capacitance` | `inductance` | `resistance` | `conductance` | `molarity`

The ***numeric-literal*** in an _integer-exponent_ term must be integral — the token value may not contain a _decimal_separator_ or _exponent_. A non-integral exponent is a syntax error.

Here, `real` denotes the dimensionless (scalar) quantity.

The named quantities above are chosen to represent ISQ quantities, but in some cases a single word is used to represent a longer ISQ quantity name to simplify the grammar. The named quantities are listed below with their equivalent ISQ quantity and dimensional expression in terms of the physical dimensions **L** (length), **M** (mass), **T** (time), **I** (electric current), **Θ*** (thermodynaic temperature), and **N** (amount of substance).

| Arblang name   | ISQ name (if different)   | ISO document | Dimension      |
|----------------|---------------------------|--------------|----------------|
| `real`         | quantity of dimension one | 80000-1      | **1**          |
| `length`       |                           | 80000-1      | **L**          |
| `mass`         |                           | 80000-1      | **M**          |
| `time`         |                           | 80000-1      | **T**          |
| `current`      | electric current          | 80000-1      | **I**          |
| `temperature`  | thermodynamic temperature | 80000-1      | **Θ**          |
| `amount`       | amount of substance       | 80000-1      | **N**          |
| `frequency`    |                           | 80000-3      | **T⁻¹**        |
| `area`         |                           | 80000-3      | **L²**         |
| `volume`       |                           | 80000-3      | **L³**         |
| `velocity`     |                           | 80000-3      | **LT⁻¹**       |
| `acceleration` |                           | 80000-3      | **LT⁻²**       |
| `momentum`     |                           | 80000-4      | **LMT⁻¹**      |
| `force`        |                           | 80000-4      | **LMT⁻²**      |
| `pressure`     |                           | 80000-4      | **L⁻¹MT⁻²**    |
| `power`        |                           | 80000-4      | **L²MT⁻³**     |
| `energy`       | kinetic energy            | 80000-4      | **L²MT⁻²**     |
|                | thermodynamic energy      | 80000-5      | **L²MT⁻²**     |
| `entropy`      | entropy                   | 80000-5      | **L²MT⁻²Θ⁻¹**  |
| `charge`       | electric charge           | 80000-6      | **TI**         |
| `voltage`      |                           | 80000-6      | **L²MT⁻³I⁻¹**  |
| `capacitance`  |                           | 80000-6      | **L⁻²M⁻¹T⁴I²** |
| `inductance`   |                           | 80000-6      | **L²MT⁻²I⁻²**  |
| `resistance`   |                           | 80000-6      | **L²MT⁻³I⁻²**  |
| `conductance`  |                           | 80000-6      | **L⁻²M⁻¹T³I²** |
| `molarity`     | amount-of-substance concentration | 80000-9 | **L⁻³N**    |

For arblang, two quantity type expressions are deemed equivalent if they have the same physical dimensionality. Equivalent type expressions describe the same type.

Quantity literals are composed from a ***numeric-literal*** and a _unit-term_ suffix. Units are represented by keywords corresponding to combinations of SI unit prefixes and SI unit abbreviations, and similarly to quantities, are composed via multiplication, division, and integer exponentiation.

> _quantity-literal_ ::= ***numeric-literal*** ***whitespace*** _unit-term_
>
> _unit-term_ ::= _unit-name_ _integer-exponent_? | _unit-product_ | _unit-quotient_
>
> _unit-product_ ::= _unit-term_ ( ***whitespace*** | ***multiplication-dot*** )  _unit-term_
>
> _unit-quotient_ ::= _unit-term_ ***division-slash*** _unit-term_
>
> _unit-name_ ::= ***symbol***

A valid unit name is a ***symbol***, but are _lexically_ described as follows.

> _unit-name_ ::= `°C` | _unit-SI-prefix_? _unit-metric_
>
> _unit-SI-prefix_ ::=  `Y` | `Z` | `E` | `P` | `T` | `G` | `M` | `k` | `h` | `da` | `d` | `c` | `m` | `μ` | `u` | `n` | `p` | `f` | `a` | `z` | `y`
>
> _unit-metric_ ::= `m` | `g` | `s` | `A` | `K` | `mol` | `Hz` | `L` | `l` |  `N` | `Pa` | `W` | `J` | `C` | `V` | `F` | `H` | `Ω` | `Ohm` | `S` | `M` | `kat`

Unit prefixes are SI unit prefix symbols, with the addition of `u` for micro-:

| Unit prefix | SI unit name | Multiple |
|-------------|--------------|----------|
| `Y`  | yotta | 10²⁴  |
| `Z`  | zetta | 10²¹  |
| `E`  | exa   | 10¹⁸  |
| `P`  | peta  | 10¹⁵  |
| `T`  | tera  | 10¹²  |
| `G`  | giga  | 10⁹   |
| `M`  | mega  | 10⁶   |
| `k`  | kilo  | 10³   |
| `h`  | hecto | 10²   |
| `da` | deca  | 10¹   |
| `d`  | deci  | 10⁻¹  |
| `c`  | centi | 10⁻²  |
| `m`  | milli | 10⁻³  |
| `μ`  | micro | 10⁻⁶  |
| `u`  | micro | 10⁻⁶  |
| `n`  | nano  | 10⁻⁹  |
| `p`  | pico  | 10⁻¹² |
| `f`  | femto | 10⁻¹⁵ |
| `a`  | atto  | 10⁻¹⁸ |
| `z`  | zepto | 10⁻²¹ |
| `y`  | yocto | 10⁻²⁴ |

Arblang metric units, and their corresponding arblang quantities:

| Unit  | Name    | Arblang quantity |
|-------|---------|------------------|
| `m`   | metre   | `length`         |
| `g`   | gram    | `mass`           |
| `s`   | second  | `time`           |
| `A`   | ampere  | `current`        |
| `K`   | kelvin  | `temperature`    |
| `mol` | mole    | `amount`         |
| `Hz`  | hertz   | `frequency`      |
| `L`   | litre   | `volume`         |
| `l`   | litre   | `volume`         |
| `N`   | newton  | `force`          |
| `Pa`  | pascal  | `pressure`       |
| `W`   | watt    | `power`          |
| `J`   | joule   | `energy`         |
| `C`   | coulomb | `charge`         |
| `V`   | volt    | `voltage`        |
| `F`   | farad   | `capacitance`    |
| `H`   | henry   | `inductance`     |
| `Ω`   | ohm     | `resistance`     |
| `Ohm` | ohm     | `resistance`     |
| `S`   | siemens | `conductance`    |
| `M`   | molar   | `molarity`       |
| `kat` | katal   | `amount/time`    |

Note that the non-SI unit 'molar' is equal to 1 mol/L.

#### Notes

There is one unit, degrees Celsius °C, which is not zero-based. Depending on context, a value expressed as _x_ °C may represent an absolute temperature, viz. (_x_+273.15) kelvin, or a temperature difference of _x_ kelvin. To avoid confusion, it is recommended that any arblang source only use °C to represent the former. For the interpretation of arblang, there are three chief possibilities, in order of increasing sophistication:

1. Simplest: always automatically convert _x_ °C to (_x_+273.15) kelvin. Use of a Celsius temperature literal in non-absolute contexts is an unflagged semantic error.
2. Conservative contextual approach: subtraction is always regarded as representing a difference, so that two compatible offset or offset-free values may be subtracted, giving an offset-free value; an offset value may be the left hand summand in an addition with a compatible non-offset value, giving an offset value. All other arithmetical expressions constitute a type error.
3. Fully contextual approach: as above, save that an offset value has its offset ignored in any arithmetical expression _except_ when it is an operand in a subtraction, or is the left hand summand in an addition.

Examples for the different interpretations, writing _x_ ⊕ _y_ for an internal representation of a value with implicit offset _y_:

| Expression      | Simple    | Conservative    | Full contextual |
|-----------------|-----=-----|-----------------|-----------------|
| 1 °C            | 274.15 K  | (1 ⊕ 273.15) K  | (1 ⊕ 273.15) K  |
| 1 °C + 3 K      | 277.15 K  | (4 ⊕ 273.15) K  | (4 ⊕ 273.15) K  |
| 1 °C - 3 °C     | -2 K      |  -2 K           | -2 K            |
| 280.15 K + 3 °C | 283.14 K  |  _error_        | 283.15 K        |
| 280.15 K - 3 °C | -2 K      |  _error_        | -2 K            |
| 1 °C + 3 °C     | 550.30 K  |  _error_        | (4 ⊕ 273.15) K  |
| 1 °C / 2        | 137.075 K |  _error_        | 0.5 K           |

All three approaches can lead to surprsing behaviour, given the differences in interprertation between addition and subtraction with offset-bearing quantities. The best approach might be to remove the °C unit altogether.


### Records


### Functions


## Modules and interfaces

Modules are used to collect parameters, constants, and function definitions; interfaces are used to define a particular sort of Arbor functionality, such as ion channel or gap junction dynamics. Module and interface definitions can only be provided at top level.

### Module definition

> _module-defn_ ::= `module` ***symbol*** `{` ( _type-alias_ | _parameter-defn_ | _constant-defn_ | _function-defn_ | _module-import_ )\* `}`
>
> _type-alias_ ::= `type` ***symbol*** `=` _type-expr_ `;`
>
> _parameter-defn_ ::= `parameter` _type-expr_? ***symbol*** `=` _expression_ `;`
>
> _constant-defn_ ::= `def` ***symbol*** _type-assertion_? `=` _expression_ `;`
>
> _constant-defn_ ::= `def` ***symbol*** _type-assertion_? `=` _expression_ `;`
>
> _function-defn_ ::= `fn` ***symbol*** _argument-list_ `=` _expression_ `;`
>
> _argument-list_ ::= `(` ( _type-expr_ ***symbol*** ( `,` _type-expr_ ***symbol*** )* )? `)`
>
> _module-import_ ::= `import` ***symbol*** ( `as` ***symbol*** )
>
> _type-assertion_ ::= `:` _type-expr_

### Interface definition

**TODO**

#### Module imports

Identifiers bound in module scope in one module can be used in another module or interface, if the module is imported. If a module `A` is imported as `B`, a type, parameter, constant, or function _x_ defined in `A` can be referenced with the qualified identifier `B`._x_.

Examples:
```
module A {
    constant real pi = 3;
}

module X {
    import module A;
    constant real pi = A.pi; # Also 3.
}

module Y {
    import module A as B;
    constant real pi = B.pi; # Also 3.
}
```

### Function definitions

**TODO**

### Type aliases

**TODO**

#### Notes

As noted above in the section on identifiers, the same identifier may not be rebound within a module or interface definition, but _is_ permitted to refer to a type in a type context, a value inan expression context, and a module in an module import context.

Type assertions are optional on the left hand side of `def` clauses, as the type of the value bound to the identifier is always deducible from the expression on the right hand side.

The expression on the right hand side of a constant definition may depend only on identifiers bound to constants. Similarly, the expression on the right hand side of a parameter definition may depend only on identifiers bound to constants or other parameters.


### Alternative function and type alias syntax

The forms for function and type alias definitions above are quite different from earlier proposals; these are reprised here if the new proposed forms are rejected:

> _function-defn_ ::= `function` ***symbol*** _argument-list_ ( `->` _type-expr_ )* `{` _expression_ `}`

Type definitions are only for record types:

> _type-alias_ ::= `record` ***symbol*** `{` ( _type-expr_ ***symbol*** `;` )\* `}`

### Parameter semantics

A parameter definition introduces a new identifer in module scope, together with a default value. Parameters can be used in any following expression within the module.
The expression to which a parameter is bound may not include identifiers that are bound in an interface to external quantities, but may include other parameters.

Parameters that are exported in an interface can be bound to a user supplied value externally; they are nonetheless constant. In any expression in the same module scope that uses that parameter, the value of the parameter will be the the user supplied value. This applies to expressions that are bound to other parameters — for example, consider the following module and interface definition.

```
module impl {
    parameter voltage a = 3 mV;
    parameter current I = (13 mV - a) / 20 kΩ;
}

interface point "foo" {
    import impl;
    export parameter impl.a as a;

    effect current = impl.I;
}
```

Models using the "foo" mechanism can set the parameter `a` to some voltage. If it remains unset, the mechanism supplies a non-specific current of 0.5 μA; if the model sets the parameter `a` to -7 mV, the parameter `I` in the `impl` module will have the value 1.0 µA, which will in turn be the supplied non-specific current.

# Refactor from here

Types, records and expressions are described below.

> &lt;interface-defn&gt; ::= `interface` &lt;interface-class&gt; &lt;string-literal&gt; `{` [ &lt;pararameter-defn&gt; | &lt;export&gt; | |&lt;combined-export-parameter-defn&gt; | &lt;constant-defn&gt; | &lt;record-alias-defn&gt; | &lt;function-defn&gt; | &lt;module-import&gt; | &lt;binding&gt; | &lt;initial-decl&gt; | &lt;regime-defn&gt; | &lt;regime-internal-decl&gt;]* `}`
>
> &lt;export&gt; ::= `export` [`density`] `parameter` [&lt;type-expr&gt;] &lt;qualified-identifier&gt; [ `as` &lt;identifier&gt; ]
>
> &lt;combined-export-parameter-defn&gt; ::= `export` [`density`] <parameter-defn>
>
> &lt;binding&gt; ::= `bind` [&lt;type-expr&gt;] &lt;identifer&gt; = &lt;bindable-state&gt; `;`
>
> &lt;initial-defn&gt; ::= `initial` [`regime` &lt;qualified-identifier&gt;] [ &lt;initial-post-expr&gt; `from` ] [&lt;type-expr&gt;] `state` `=` &lt;expression&gt; `;`
>
> &lt;initial-post-expr&gt; ::= `steady` | `evolve` `for` &lt;expression&gt;
>
> &lt;regime-defn&gt; ::= `regime` &lt;identifier&gt; `{` [ &lt;regime-internal-defn&gt; | &lt;regime-defn&gt; ] `}`
>
> &lt;regime-internal-defn&gt; ::= `evolve-defn` | &lt;when-defn&gt; | &lt;effect-defn&gt;
>
> &lt;evolve-defn&gt; ::= `evolve` [`explicit`] [&lt;type-expr&gt;] `state'` `=` &lt;expression&gt; `;`
>
> &lt;when-defn&gt; ::= `when` &lt;when-condition&gt; `;` [ `regime` &lt;qualified-identifier&gt; ] `state` `=` &lt;expression&gt; `;`
>
> &lt;when-condition&gt; ::= &lt;expression&gt; | [&lt;type-expr&gt;] &lt;identifier&gt; = ( `event` | `post` )
>
> &lt;effect-defn&gt; ::= &lt;effect&gt; = &lt;expression&gt; `;`

The sets of possible bindable states, effects, and interface classes are finite, but may be extended in the future. Not all bindable states or effects are permissible in all interface classes. `density` parameters are intended to describe parameters that may be linearly interpolated, and are only supported in interface classes where this is meaningful.

> &lt;interface-class&gt; ::= `density` | `discrete` | `concentration`
>
> &lt;bindable-state&gt; ::= `state` | `membrane` `potential` | `temperature` | (`current` `density` | `molar` `flux`) &lt;species-name&gt;) | (`internal` | `external`) `concentration` &lt;species-name&gt; | `charge` &lt;species-name&gt;
>
> &lt;effect&gt; ::= `current` `density` [&lt;species-name&gt;] | `molar` `flow` `rate` &lt;species-name&gt; | `current` [&lt;species-name&gt;] | `molar` `flux` &lt;species-name&gt; | (`internal` | `external`) `concentration`
>
> &lt;species-name&gt; ::= &lt;string-literal&gt;

## Module semantics

**TODO:** explain parameters; module imports.

## Interface semantics

An interface provides, generally:

1. A _state_ that evolves over time, as a function of various local cellular quantities.
2. A set of user-settable parameters.
3. A set of _effects_ that the state imposes locally upon the cell.

The initial state and its type is given by the `initial` declaration. For example,
```
    initial state = { a = 0 S; b = 0 S; };
```
declares the state has type `record { conductance a; conductance b; }` and that its initial
value has zero in both fields.

The initial state can be qualified with `steady` or `evolve for` to indicate that the provided value should be integrated over time by some given value or until steady state before being used as an initial value. The evolution is that given by subsequent `evolve` declarations. The degree to which this is supported in an implementation will depend very much on the nature of the evolution function(s).

Evolution is governed by one or more _regimes_. In the simplest case, there is just the one, default regime, but more generally, multiple regimes may be defined, and transitions between them can be triggered by boolean-valued expressions that are a function of state and bound cell quantities, or by pre- or post-synaptic events. Regime definitions can be nested, and an inner regime definition inherits any triggers from the enclosing scope, and the evolution function from the enclosing scope as well, if it is not overridden. The initial regime can be specified in the `initial` definition. The default regime has no name, and so cannot be a target of `regime` clauses in a `when` definition.

The evolution function is defined with the `evolve` definition, and there may only be one `evolve` per regime. The expression on the rhs must have type equal to the 'derivative' type of the state. The derivative of a quantity is that quantity divided by time; the derivative of a record type is the record type where each field _x_ is replaced by a field _x'_ with type the derivative type of _x_. See the discusion under record types below for more details.

Effects tie the state to the cell, defining how the state determines ionic currents or species flows, or how it governs species concentrations.

Exports make parameters visible and settable by models that employ the interface. As a convenience, an export and a parameter definition can be combined in a single export declaration.

If the interface doesn't require any evolving state, it can omit the `initial` and `evolve` definitions.

### Density models

Density models represent a process which is distributed over an areal extent of the cell membrane. Parameters defined in density models may be labelled as `density` parameters — such parameters are declared to be safe to interpolate, and can be used with spatitally varying scaling, for example.

Bindable states: state; membrane potential; temperature; internal/external concentration "_species_"; charge "_species_".

Effects: current density (non-specific); current density "_species_"; molar flux "_species_".

Events: only boolean-valued expressions.

### Discrete models

Discrete models capture localized effects and can react in response to incoming spike events or post-synaptic spike detection events. They may not have `density` parameters.

Bindable states: state; membrane potential; temperature; internal/external concentration "_species_"; charge "_species_".

Effects: current (non-specific); current "_species_"; molar flow rate "_species_".

Events: any.

### Concentration models

Concentration models determine the internal and/or external concentration of a species over time. As specified, only one concentration model can be used to determine the state of a species in any given region of a cell. The initial value of the state determines the initial value(s) of the concentration.

Bindable states: state; membrane potential; temperature; current density "_species_"; molar flux "_species_"; charge "_species_". Note that the concentrations themselves are _not_ bindable.

Effects: internal/external concentration "_species_".

Events: only boolean-valued expressions.

### Alternative concentration model

There are a couple of problems with specifying concentration evolution with concentration models as outlined above:
* Concentration models cannot be combined for any given species.
* Initial concentration is determined by the model, disregarding any user-supplied initial concentration data.

A cleaner approach would be to present a concentration model in terms of the change in concentration over time. Then the initial value would be user-specified, and multiple concentration model contributions could overlap.

Example, concentration model:
```
interface concentration "CaDynamics" {
    export parameter real gamma = 0.5;
    export parameter time decay = 80 ms;
    export parameter length detph = 0.1 µm;
    export parameter concentration steady_conc = 1.0e-4 mmol/L;

    initial state = steady_conc;

    bind ca_conc = state;
    bind ca_flux = molar flux "ca";
    evolve state' = -ca_flux*gamma/depth - (ca_conc-steady_conc)/decay;

    effect internal concentration "ca" = ca_conc;
}
```

Alternative concentration rate model:
```
interface concentration "CaDynamics" {
    export parameter real gamma = 0.5;
    export parameter time decay = 80 ms;
    export parameter length detph = 0.1 µm;
    export parameter concentration steady_conc = 1.0e-4 mmol/L;

    bind ca_flux = molar flux "ca";
    bind ca_conc = internal concentration "ca";
    effect internal concentration rate "ca" =
            -ca_flux*gamma/depth - (ca_conc-steady_conc)/decay;
}
```

The alternative model could have been split into two different models, to be applied over the same regions:
```
interface concentration "CaUnbuffered" {
    export parameter real gamma = 0.5;
    export parameter length depth = 0.1 µm;

    bind ca_flux = molar flux "ca";
    effect internal concentration rate "ca" = -ca_flux*gamma/depth;
}

interface concentration "CaBuffered" {
    export parameter concentration steady_conc = 1.0e-4 mmol/L;
    export parameter time decay = 80 ms;

    bind ca_conc = internal concentration "ca";
    effect internal concentration rate "ca" = -(ca_conc-steady_conc)/decay;
}
```

## Function definitions

**TODO**

# Types and type expressions

Every expression has a type, which is either:

1. A boolean value.
2. A quantity (see below).
3. A record type, comprising an unordered sequence of named fields, with each field being either a quantity or another record type.

Type descriptions are explicitly required in:

1. Record field type declarations.
2. Function parameter declarations.

Type descriptions are optional in contexts where the type can be deduced:

1. In `bind` and `parameter` declarations.
2. In `let` and `with` expressions.
3. In function return value type declarations.

A type expression &lt;type-expr&gt; describes a type; different type expressions may describe the same type.

| &lt;type-expr&gt; ::= `boolean` | &lt;quantity-expr&gt; | &lt;record-type-expr&gt;

## Quantities

Quantities represent physical quantities, which in turn comprise a magnitude and a physical dimension. The specific unit scale underlying the representation of a physical quantity is implicit.

A quantity type is defined as a product term of named quantities such as voltage, time, resistance, etc. The set of named quantities is predefined, and can't be extended within arblang. Quantity syntax:

> &lt;quantity-expr&gt; ::= &lt;quantity-name&gt; | &lt;quantity-product&gt; | &lt;quantity-quotient&gt; | &lt;quantity-power&gt;
>
> &lt;quantity-product&gt; ::= &lt;quantity-expr&gt; &lt;product-symbol&gt; &lt;quantity-expr&gt;
>
> &lt;product-symbol&gt; ::= &lt;whitespace&gt; | &lt;multiplication-dot&gt;
>
> &lt;quantity-quotient&gt; ::= &lt;quantity-term&gt; &lt;division-slash&gt; &lt;quantity-term&gt;
>
> &lt;quantity-power&gt; ::= &lt;quantity&gt; `^` &lt;integer&gt; | &lt;quantity&gt; &lt;integer-superscript&gt;
>
> &lt;integer&gt; ::= [&lt;minus-sign&gt;] &lt;digit&gt;+
>
> &lt;digit&gt; ::= `0` | `1` | ... | `9`
>
> &lt;integer-superscript&gt; ::= [ `⁻` ] &lt;digit-superscript&gt;+
>
> &lt;digit-superscript&gt; ::= `⁰` | `¹` | ,,, | `⁹`
>
> &lt;quantity-name&gt; ::= `real` | `length` | `mass` | `time` | `current` | `amount` |
>   `temperature` | `charge` | `frequency` | `voltage` | `resistance` |
>   `capacitance` | `force` | `energy` | `power` | `area` | `volume` | `concentration`

Here, 'real' denotes the dimensionsless (scalar) quantity.

The named quantities above are chosen to represent ISQ quantities, but in some
cases a single word is used to represent a longer ISQ quantity name to simplify
the grammar. These map to ISQ quantities as follows:

`amount`
  ~ amount of substance

`current`
  ~ electic current

`time`
  ~ time duration

`temperature`
  ~ thermodynamic temperature

`charge`
  ~ electric charge

`resistance`
  ~ electric resistance

`voltage`
  ~ electric potential difference

Examples:

```
let real a = 2.0;
let voltage v = 2 mV;
let current/area/time g' = 1 nA/mm²/ms; # a time derivative of areal current density.
let capacitance⋅length⁻² c = 2 F/cm²; # a contrived way of writing capacitance/area
```

Unlike ISQ quantities, there is one quantity type provided per dimensionally-equivalent class, where 'amount' is considered as its own dimension, distinct from dimensionless quantities. This means, for example, that there is no type support for preventing a concentration of Na⁺ being used in a context expecting a concentration of Ca⁺⁺, or for distinguishing between 'catalytic activity' and 'amount of substance per time', or even between plane and solid angles.

Expressions which evaluate to a given quantity follow normal algebraic rules; constant values must be introduced with a compatible unit.

```
let voltage v = 23 * 10 mV - 2 μV;
```

**Note:** Luminous intensity is excluded above, but perhaps we should include it for completeness.

## Record types

A record is a labelled unordered tuple of values which are either quantities or records themselves. A record may not have two fields of the same name. A record type specification has the syntax:

> &lt;record-type-expr&gt; ::= &lt;record-type&gt; | &lt;record-alias&gt; | &lt;derivative-record&gt;
>
> &lt;record-alias&gt; ::= &lt;identifier&gt;
>
> &lt;record-type&gt; ::= `record` &lt;record-type-body&gt;
>
> &lt;record-type-body&gt; ::= `{` &lt;record-field&gt;* `}`
>
> &lt;record-field&gt; ::= &lt;type-expr&gt; &lt;identifier&gt; `;`

A record alias is an identifier that has bound to a record type in a record alias definition (see above).

### Record type aliases and derivative records.

See the Modules and Interfaces section for the definition syntax.

When an identifier _x_ is bound as a record alias, then the symbols _x_', _x_'', etc. are also bound as record aliases. The alias _x_' is bound to the _time derivative_ record type of _x_.

If a record type has fields named F<sub>1</sub>, F<sub>2</sub>, … with types T<sub>1</sub>, T<sub>2</sub>, … then its time derivative record has fields named F<sub>1</sub>', F<sub>2</sub>', … and types T<sub>1</sub>', T<sub>2</sub>', … where T' is the time derivative record of T if T is a record, or else is the quantity T/time if T is a quantity.

Example: with the record aliases
```
    record foo { real a; length b; }
    record bar { amount c; foo d; }
```
the type `bar'` is equivalent to the definition
```
    record bar' {
        amount/time c';
        record { frequency a'; length/time b'; } d';
    }
```

### Row polymorphism

A record type is a _subrecord_ of another type for every field _F_ in the first record type is also a field _G_ in the second record type with the same field name, and the type of _F_ is either the same as the type of _G_ or is a subrecord of the type of _G_.

**TODO:** a record supertype can be bound to a parameter or identifier with a specified record subtype.

# Expressions

An expression corresponds to something that can be evaluated to give a value. They can be a literal value, or some
combination of literal values, bound identifiers, arithemetic and record operations, function invocations, local bindings, and comparisons.

> &lt;expression&gt; = &lt;value-literal&gt; | `(` &lt;expression;&gt; `)` | &lt;function-call&gt; | &lt;arithemtic-expr&gt; | &lt;record-expr&gt; | &lt;boolean-expr&gt; | &lt;conditional-expr&gt; | &lt;let-expr&gt; | &lt;with-expr&gt;

## Literal values

A literal scalar value is just a decimal representation of a real number,
while a non-scalar literal value is written as a decimal number followed by a unit
description. The unit descriptions follow a grammar analagous to the quantity
descriptions (see above).

> &lt;value-literal&gt; ::= &lt;number&gt; | &lt;number&gt; &lt;whitespace&gt; &lt;unit-term&gt;
>
> &lt;unit-term&gt; ::= &lt;unit&gt; | &lt;unit-product&gt; | &lt;unit-quotient&gt; | &lt;unit-power&gt;
>
> &lt;unit-product&gt; ::= &lt;unit-term&gt; &lt;multiplication-dot&gt; &lt;unit-term&gt; | &lt;unit-term&gt; &lt;whitespace&gt; &lt;unit-term&gt;
>
> &lt;unit-quotient&gt; ::= &lt;unit-term&gt; &lt;division-slash&gt; &lt;unit-term&gt;
>
> &lt;unit-power&gt; ::= &lt;unit-term&gt; `^` &lt;integer&gt; | &lt;unit-term&gt; &lt;integer-superscript&gt;
>
> &lt;unit&gt; ::= [ &lt;si-prefix-symbol&gt; ] &lt;si-unit-symbol&gt; | &lt;convenience-unit&gt;
>
> &lt;si-prefix-symbol&gt; ::= `Y` | `Z` | `E` | `P` | `T` | `G` | `M` | `k` | `h` | `da` | `d` | `c` | `m` |
>    `μ` | `µ` | `u` | `n` | `p` | `f` | `a` | `z` | `y`
>
> &lt;si-unit-symbol&gt; ::= `s` | `m` | `g` | `A` | `K` | `mol` | `L` | `l` | `Hz` | `N` | `J` | `Pa` | `W` | `C` | `F` | `V` | `Ω` | `S` | `kat` | ...
>
> &lt;convienience-unit&gt; ::= `°C` | `°F` | ...

(Where &lt;number&gt; stands for the regular sorts of decimal representation supported by e.g. JSON.)

Note that `*` is _not_ permitted as a product symbol between units in this proposal. This is in accordance with SI typographical conventions and reduces the risk of misinterpretation where a literal value is used in a term together with an identifier which has the same spelling as an SI unit, e.g.

> 1 cm*cm

would unambiguously mean the product of one centimetre with the value 'cm'. There still remains the problem of e.g.

> 1 cm/cm

which would, if unit terms are given precedence, denote one centimetre per centimetre. As parantheses are also not permitted in unit terms as proposed above, the quotient of one centimetre and the value 'cm' could be denoted by

> 1 cm / cm # Space or lack thereof is significant in unit terms.
> 1 cm/(cm) # Parentheses can't be part of a unit term.

or with maximum clarity, by

> (1 cm)/cm

The type of a literal value is the quantity that is dimensionaly compatible with the given unit.

## Boolean expressions and conditionals

Boolean expressions are those expressions that evalue to a boolean value. They comprise the boolean literals `true` and `false`, and comparisons.

> &lt;boolean-expr&gt; ::= `true` | `false` | &lt;expression&gt; &lt;comparison-op&gt; &lt;expression&gt; | &lt;expression&gt; &lt;logical-op&gt; &lt;expression&gt;
>
> &lt;comparison-op&gt; ::= `<` | `<=` | `>` | `>=` | `==` | `!=`
>
> &lt;logical-op&gt; ::= `not` | `and` | `or`

Conditional expressions evaluate to one of two sub-expressions based on a boolean value.

> &lt;conditional-expr&gt; ::= `if` &lt;expression&gt; `;` `then` &lt;expression&gt; `else` &lt;expression&gt;

### Alternative conditional syntax

In order to avoid nested `if` expressions, we could also or instead adopt a guard-style syntax. The last clause must have condition `true`, or as syntactic sugar, `otherwise`.

**TODO:** Syntax definition.

Example:
```
let q =
  | a==3 => 1
  | otherwise => sin(a)/a;
```

### Semantics

Comparisons can only be performed between quality values of the same type, or between records that are of the same type, or where one is a subrecord of the other. For record comparisons, the expression evaluates to true if the comparison holds true for each field in the subrecord.

Logical operations are only defined for boolean values.

## Arithmetic expressions

Arithmetic operations — multiplication, division, addition and subtraction —
can be used to form expressions involving values provided that there is
an agreement in quantity. Exponentiation of scalar values is freely permitted,
but exponentiation of non-scalar values is only defined under particular
circumstances.

**TODO**: All the details.

## Record expressions

A record values can be specified by the field values in a record construction:

> &lt;record-construction&gt; ::= `{` &lt;record-field-binding&gt;* `}`
>
> &lt;record-field-binding&gt; ::= [ &lt;type-expr&gt; ] &lt;identifier&gt; `=` &lt;field-value&gt; `;`
>
> &lt;field-value&gt; ::= &lt;expression&gt;

As an example, the following expression has the type `record { voltage a; real b; }`
```
{ real b = 2; a = 3 mV; }
```
where the type of the field `a` is deduced from the rhs of the binding.

Record values support two operations: field access, and update.

> &lt;record-expr&gt; ::= &lt;field-expr&gt; | &lt;update-expr&gt;
>
> &lt;field-expr&gt; ::= &lt;expression&gt; `.` &lt;identifier&gt;
>
> &lt;update-expr&gt; ::= &lt;expression&gt; `:` &lt;expression&gt;

The update operation `:` takes two record values, with the rhs a subrecord of the lhs, and returns a record of the same type as the lhs. Each field has the value taken from the rhs if present in the subrecord type, or otherwise the value taken from the lhs.

In the following example,
```
let p = { a = 3.0; b = 10 A; };
let q = p : { b = 20 A; };
```
the identifier `q` is bound to the record value `{ a = 3.0; b = 20 A; }`.

## Local binding expressions

`let` and `with` bind identifiers to expressions or record fields. `with` could also possibly be used to bring into scope identifiers defined in an imported module.

> &lt;let-expr&gt; ::= `let` [&lt;type-expr&gt;] &lt;identifier&gt; = &lt;expression&gt; `;` &lt;expression&gt;
> &lt;with-expr&gt; ::= `with` [&lt;type-expr&gt;] &lt;expression&gt; `;` &lt;expression&gt;

The identifiers introduced by `let` or `with` have only the terminal expression as scope.

**TODO:** Examples!

# Syntax discussion and alternatives

## Semicolons

The proposal above requires semicolons only in three circumstances: when associating or binding something after an equals sign; when making local bindings in a with-expression; after a conditional in a when-clause; or when declaring fields in a record type:
```
# Semicolons after `=` and expression:
parameter length² A = 3 m²;
bind S = state;
effect current "na" = 3 mA;
let real a = S.a; 3+a

# Semicolon after first expression in `with`:
with S; 3+a

# Semicolon after field definition in record type,
# as well as in record value fields.
let record { concentration x; } b = { x = 3; }; 3+b.x

# No semicolon after record type alias.
record foo { real x; }

# Or after function definition.
function bar () { 3 }

# Or after a paramater alias,
density parameter ca2_dynamics.foo as foo

# OR after import, etc.
import std as foobar

```

Why have semicolons at all? It can disambiguate alternative possible parses when two expressions are adjacent, which is a situation that arises from allowing whitespace to act as a product in quantity and unit expressions:
```
let A = 3 A A - 4 A
```
could be interpreted as binding `A` to the value 3 square amperes and returning negative four amperes, or binding `A` to the value 3 amperes, and then returning `A` minus four amperes, giving negative one ampere. The semicolon resolves this one way or the other:
```
let A = 3 A; A - 4 A
```

Why not have semicolons more commonly? It's certainly possible: they could be added after every `import` or record alias or function definition, but it is not necessary for the resolution of ambiguities. An alternate function and alias syntax described below could help unify some of these syntaxes.


## Function alternatives and type aliases

As presented above, functions are fairly inflexible: they can only be defined in module/interface scope, and they are not permitted to be polymorphic.

Functions could be allowed to be defined locally with a syntax like e.g.
```
function five() {
    let f = function (real a, real b) { a+b };
    f(3, 2)
}
```
in which case a uniform definition syntax might replace `function _name_ (params...) ...`, e.g.
```
def five = function () {
    let f = function (real a, real b) { a+b };
    f(3, 2)
};
```
And rather than be so verbose, we could use something like `fn` instead.

A problem with this is that it makes functions look like values, and values should be things you can return from functions, etc., and suddenly for consistency it looks like we might want to support functions as first class objects. This would increase expressiveness, but would also make the type system more complicated. For the domain, this is probably not an expressiveness we need.

However, we could make a distinction between binding local identifiers with `let` and introducing new function or record aliases with e.g. `def`. Then the example would become
```
def five = fn () {
    def f = fn (real a, real b) { a+b };   # 'f' is _not_ a value!
    f(3, 2)
};
```
and this would allow a general approach to function aliases, type naming, and derivative type forms:
```
def model_state = record { real a; concentration b; }; # record alias

def ca_model = concentration; # quantity alias
def ca_rate = fn (ca_model conc) -> ca_model' { conc/20 ms }; # ca_model' automatically defined as concentration/time

import std
def nernst = std.nernst; # 'nernst' is another name for the 'std.nernst' function.
```

If `def foo = fn (...) { ... };` looks a little verbose, we could keep `def foo(...) { ... }` as syntactic sugar.

## Magic keywords and extension points

Within an interface block, there are specific points within the permitted syntax where keywords are used to refer to interface-specific values or concepts, and which constitute natural places for future extensions of the interface block to support new functionality:

1. Right hand side of `bind`, corresponding to interface-specific exposed values, such as the mechanism state, ion concentrations, membrane voltage, etc.
2. Right hand side of local binding in a `when` clause, tying event or post-event data to an identifier.
3. Left hand side of `effect`, corresponding to contributions of the interface to the simulation state.
4. Left hand side of `initial`, where the optional `... from` clause modifies the initial state, and also where `state` forms the left hand side of the final binding.
5. Left hand side of `evolve`, where the keyword `explicit` might be replaced with other possible descriptions, such as `implicit` for implicit ODE or DAE systems, and also where `state'` forms left hand side of the final binding.
6. Left hand side of `export`, where we have `density parameter` or `parameter`, but which could be extended to support for example the exposure of derived values to probe requests or similar.

**TODO:** Add examples of possible syntax extensions in these cases.
